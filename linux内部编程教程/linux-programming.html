<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:linux-programming</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-io">文件IO</h1>
<p><strong> 学习目标 </strong></p>
<ul>
<li>熟练掌握Linux系统IO函数的使用<ul>
<li>open</li>
<li>close</li>
<li>read</li>
<li>write</li>
<li>lseek</li>
</ul>
</li>
<li>了解阻塞和非阻塞的概念</li>
</ul>
<h2 id="open-close">open/close</h2>
<ul>
<li>函数原型:<ul>
<li>int open(const char *pathname, int flags);</li>
<li>int open(const char *pathname, int flags, mode_t mode);</li>
</ul>
</li>
<li>参数:<ul>
<li>flags</li>
</ul>
</li>
<li>必选项 O_RDONLY, O_WRONLY, O_RDWR</li>
<li>可选项<ul>
<li>创建文件: O_CREAT
◊ 创建文件时检测文件是否存在: O_EXCL
◊ 如果文件存在, 返回-1
◊ 必须与O_CREAT一起使用</li>
<li>追加文件: O_APPEND</li>
<li>文件截断: O_TRUNC</li>
<li>设置非阻塞: O_NONBLOCK</li>
<li>mode<ul>
<li>mode &amp; ~umask</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>0777 &amp; ~0002
111111111
111111101
  * &amp;
111111101
</code></pre><h2 id="read">read</h2>
<ul>
<li>函数原型: ssize_t read(int fd, void *buf, size_t count);</li>
<li>参数:<ul>
<li>fd: open的返回值</li>
<li>buf:缓冲区,存储要读取的数据</li>
<li>count:缓冲区能存储的最大字节数 sizeof(buf)</li>
</ul>
</li>
<li><p>返回值:</p>
<ul>
<li><p>-1:失败</p>
</li>
<li><p>成功:</p>
<ul>
<li>> 0: 读出的字节数</li>
<li>=0:文件读完了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="write">write</h2>
<ul>
<li>函数原型: ssize_t write(int fd, const void *buf, size_t count);</li>
<li>参数:<ul>
<li>fd:open返回值</li>
<li>buf:要写到文件的数据</li>
<li>count:strlen(buf)</li>
</ul>
</li>
<li>返回值:<ul>
<li>-1: 失败</li>
<li>>0: 写入到文件的字节数</li>
</ul>
</li>
</ul>
<h2 id="lseek">lseek</h2>
<ul>
<li>函数原型: off_t lseek(int fd, off_t offset, int whence);</li>
<li>参数：<ul>
<li>文件指针移动到头部</li>
<li>文件指针移动到尾部</li>
<li>获取文件指针的位置</li>
</ul>
</li>
</ul>
<h2 id="-">阻塞和非阻塞</h2>
<ul>
<li>阻塞和非阻塞是文件的属性还是read函数的属性?<ul>
<li>文件的属性</li>
<li>普通文件:hello.c</li>
</ul>
</li>
<li>默认不阻塞<ul>
<li>终端设备:/dev/tty</li>
<li>默认阻塞</li>
<li>管道</li>
<li>套接字</li>
</ul>
</li>
</ul>
<h2 id="-">练习</h2>
<ul>
<li><p>编写cp命令</p>
<ul>
<li>有一个文件,open,数据读出来, 读出的数据写到另一个文件中,    </li>
</ul>
</li>
<li><p>编写cat命令</p>
<ul>
<li>有一个文件,open,数据读出来, 读出的数据显示到屏幕上     </li>
</ul>
</li>
</ul>
<h1 id="-">文件和目录操作函数</h1>
<ul>
<li><p><strong>学习目标</strong></p>
</li>
<li><p>掌握stat/lstat函数的使用</p>
</li>
<li>了解文件属性相关的函数使用</li>
<li>了解目录操作相关的函数的使用</li>
<li>掌握目录遍历相关函数的使用</li>
<li>掌握dup、dup2函数的使用</li>
<li>掌握fcntl函数的使用</li>
</ul>
<h2 id="-">文件属性</h2>
<h3 id="stat">stat</h3>
<p> 获取文件属性， 也就是inode的内容。 当文件是符号链接时， 获取的是符号链接指向的那个文件的属性。也就是所谓的“穿透”。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int stat(const char <em>pathname, struct stat </em>buf);<blockquote>
<ul>
<li>int lstat(const char <em>pathname, struct stat </em>buf);</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pathname：给定文件</li>
<li>buf： 返回文件的属性（inode）信息 </li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 0</li>
<li>失败： -1， 并设置errno</li>
</ul>
</li>
<li><p><strong>重点结构体</strong></p>
</li>
</ul>
<pre><code class="lang-C">struct stat {
dev_t  st_dev;   //文件的设备编号
ino_t  st_ino;  //节点
mode_t st_mode; //文件的类型和存取的权限 **
nlink_t  st_nlink; //连到该文件的硬连接数目 **
uid_t  st_uid;  //用户ID **
gid_t  st_gid;  //组ID **
dev_t  st_rdev; //(设备类型)若此文件为设备文件,则为其设备编号
off_t  st_size; //文件字节数(文件大小) **
blksize_t st_blksize; //块大小(文件系统的I/O 缓冲区大小)
blkcnt_t st_blocks; //块数
struct timespec st_atim;  /*最后一次访问时间 */
struct timespec st_mtim;  /* 最后一次修改时间 */ **
struct timespec st_ctim;  /* 最后一次改变时间(指属性) */
};
</code></pre>
<ul>
<li><p>st_mode -- 16位整数</p>
<ul>
<li><p>0-2 bit -- 其他人权限</p>
<ul>
<li>S_IROTH 00004 读权限</li>
<li>S_IWOTH 00002 写权限</li>
<li>S_IXOTH 00001 执行权限</li>
<li>S_IRWXO 00007 掩码, 过滤 st_mode中除其他人权限以外的信息</li>
</ul>
</li>
<li><p>3-5 bit -- 所属组权限</p>
<ul>
<li>S_IRGRP 00040 读权限</li>
<li>S_IWGRP 00020 写权限</li>
<li>S_IXGRP 00010 执行权限</li>
<li>S_IRWXG 00070 掩码, 过滤 st_mode中除所属组权限以外的信息</li>
</ul>
</li>
<li><p>6-8 bit -- 文件所有者权限</p>
<ul>
<li>S_IRUSR 00400 读权限</li>
<li>S_IWUSR 00200 写权限</li>
<li>S_IXUSR 00100 执行权限</li>
<li>S_IRWXU 00700 掩码, 过滤 st_mode中除文件所有者权限以外的信息</li>
</ul>
</li>
<li><p>12-15 bit -- 文件类型</p>
<ul>
<li>S_IFSOCK  0140000 套接字</li>
<li>S_IFLNK  0120000 符号链接(软链接)</li>
<li>S_IFREG  0100000 普通文件</li>
<li>S_IFBLK  0060000 块设备</li>
<li>S_IFDIR  0040000 目录</li>
<li>S_IFCHR  0020000 字符设备</li>
<li>S_IFIFO  0010000 管道</li>
<li>S_IFMT 0170000 掩码,过滤 st_mode中除文件类型以外的信息</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件类型典型用法</strong></p>
</li>
</ul>
<pre><code class="lang-c">/*以文件类型为例*/
stat(pathname, &amp;sb);
swtch (sb.st_mode &amp; S_IFMT){
    case S_IFREG: 
         /* 普通文件 */
        break; 
    default:
        ;
</code></pre>
<p>或者</p>
<pre><code class="lang-c">/*文件类型*/
stat(pathname, &amp;sb);
if (S_ISREG(sb.st_mode)) {
    /* 普通文件 */
}
</code></pre>
<ul>
<li><strong>文件权限典型用法</strong></li>
</ul>
<pre><code class="lang-c">char perm[10]={0};
perm[0]=((st.st_mode &amp; S_IRWXU) &amp; S_IRUSR) ? &#39;r&#39;: &#39;-&#39;; /* 文件属主读权限 */
</code></pre>
<h3 id="lstat">lstat</h3>
<p> 获取文件属性， 也就是inode的内容. 当文件是符号链接， 获取的是符号链接本身的属性。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int lstat(const char <em>pathname, struct stat </em>buf);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pathname：给定文件</li>
<li>buf： 返回文件的属性（inode）信息 </li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 0</li>
<li>失败： -1， 并设置errno</li>
</ul>
</li>
</ul>
<h2 id="-">文件属性操作函数</h2>
<blockquote>
<p>所谓文件的属性，简单讲就是 <code>ls -l</code> 显示的，除去文件名之外的内容，像文件的权限、属主。</p>
</blockquote>
<h3 id="access">access</h3>
<p> access 函数是用来检测当前用户对指定文件是否具有某种权限（读、写、执行、文件存在）。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int access(const char *pathname, int mode);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pathname： 文件名称</li>
<li>mode： 包括四种权限<ul>
<li>R_OK: 读</li>
<li>W_OK: 写</li>
<li>X_OK: 执行</li>
<li>F_OK: 文件是否存在</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0， 表示具备该权限（或者文件存在）</li>
<li>失败：1，并设置errno，表示不具备该权限（或者文件不存在）</li>
</ul>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<pre><code class="lang-c">int ret;
if ((ret = access(argv[1], W_OK)) == 0){
    /* 具备读权限 */
}
</code></pre>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h3 id="chmod">chmod</h3>
<p>修改给定文件的权限， 可参考<code>chmod</code>命令。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int chmod(const char *filename, int mode);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>filename: 文件名</li>
<li>mode: 文件权限, 八进制数</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0</li>
<li>失败: -1， 并设置errno </li>
</ul>
</li>
<li><p><strong>示例代码</strong></p>
</li>
</ul>
<pre><code class="lang-c">int mode = strtol(argv[2], NULL, 8);
int ret;
if ((red = chmod(argv[1], mode)) == 0){
    /* 修改成功 */;
}
</code></pre>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h3 id="chown">chown</h3>
<p> chown函数用来修改给定文件的属主和属组。</p>
<blockquote>
<p>可回顾一下chown命令</p>
</blockquote>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int chown(const char *path, uid_t owner,gid_t group);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>path： 文件路径</li>
<li>owner: 属主ID， 无符号整形值， <ul>
<li>可根据/etc/passwd,  “翻译”uid为用户名</li>
</ul>
</li>
<li>group： 属组ID, <ul>
<li>/etc/group </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 0</li>
<li>失败： -1， 并设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<pre><code class="lang-c">int ret;
if ((ret = chown(argv[1], 1000, 1001)) == 0){
    /*文件属主修改成功*/
}
</code></pre>
<blockquote>
<p>XMind小结</p>
</blockquote>
<h3 id="truncate">truncate</h3>
<p> 缩减或拓展文件尺寸到给定大小</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int truncate(const char *path, off_t length);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>path： 文件名</li>
<li>length: 文件的最终大小<ul>
<li>比原来文件长度小, 删掉后边的部分</li>
<li>比原来文件长度大, 向后拓展</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 0</li>
<li>失败： -1, 并设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<blockquote>
<p>XMmind小结</p>
</blockquote>
<h2 id="-">目录操作</h2>
<h3 id="rename">rename</h3>
<p> rename函数实现文件更名操作，等同于<code>mv</code>， （或者<code>rename</code>）</p>
<ul>
<li><strong>函数原型</strong><ul>
<li>int rename(const char *oldpath, const char* newpath);</li>
</ul>
</li>
<li><strong>函数参数</strong><ul>
<li>oldpath： 原文件名</li>
<li>newpath： 更名后的文件名</li>
</ul>
</li>
<li><strong>返回值</strong><ul>
<li>成功：0</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<h3 id="chdir">chdir</h3>
<p>  修改当前进程(应用程序)的工作路径, 参见<code>cd</code> 命令</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int chdir(const char *path);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>path：切换的路径</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<h3 id="getcwd">getcwd</h3>
<p> 获取当前进程的工作目录 参见<code>pwd</code> 命令 </p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>char *getcwd(char *buf, size_t size);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>buf：用来存储当前工作目录的缓冲区</li>
<li>size: buf缓冲的大小</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：返回指向buf的指针</li>
<li>失败： NULL， 并设置errno</li>
</ul>
</li>
</ul>
<h3 id="mkdir">mkdir</h3>
<p>创建目录</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int mkdir(const char *pathname, mode_t mode);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pathname：创建的目录名</li>
<li>mode： 目录权限, 八进制的数<ul>
<li>实际权限，mode &amp; ~umask</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<h3 id="mkdir">mkdir</h3>
<p> 删除一个空目录</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int rmdir(const char *pathname);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pathname：空目录的名字</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<h2 id="-">目录遍历</h2>
<h3 id="opendir">opendir</h3>
<p>打开一个指定目录</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>DIR *opendir(const char *name);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>name：打开的目录文件名称</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：指针， 一个用来标识所打开目录的指针</li>
<li>失败： NULL, 设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>在之前学习 fopen， FILE* fp = fopen()， fgets（buf, len, fp）</p>
</blockquote>
<h3 id="readdir">readdir</h3>
<p>读取opendir所打开的目录</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>struct dirent *readdir(DIR *dirp);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>dirp：opendir的返回值</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 指针，指向目录项结构体的指针，读到文件末尾时，返回NULL，且不改变errno</li>
<li>失败： NULL, 设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>特别提示， 标准调用方式</p>
</blockquote>
<pre><code class="lang-c">errno = 0;
struct dirent *pdire;
pdire = readdir(dirp);
if (pdire != NULL){
    /*读到有效的目录想*/
} esle if ((pdire == NULL) &amp;&amp;（errno==0)){
    /*读到目录文件结尾尾*/
} esle{   /*pdire==NULL, &amp;&amp; errno !=0*/
    /*readdir 出错*/
}
</code></pre>
<ul>
<li><strong>目录项结构体</strong></li>
</ul>
<pre><code class="lang-C">struct dirent
{
ino_t d_ino;                 // inode
ff_t d_off;                  // 目录文件开头至此目录进入点的位移
signed short int d_reclen;  // d_name 的长度, 不包含NULL 字符
unsigned char d_type;       // d_name 所指的文件类型 *
har d_name[256];            // 文件名 以空字符结尾。
};
</code></pre>
<ul>
<li><strong>类型 d_type</strong><ul>
<li>d_type<ul>
<li>DT_BLK - 块设备</li>
<li>DT_CHR - 字符设备</li>
<li>DT_DIR - 目录</li>
<li>DT_LNK - 软连接</li>
<li>DT_FIFO - 管道</li>
<li>DT_REG - 普通文件</li>
<li>DT_SOCK - 套接字</li>
<li>DT_UNKNOWN - 未知</li>
</ul>
</li>
<li>典型用法</li>
</ul>
</li>
</ul>
<pre><code class="lang-c">struct dirent *pdire;
pdire = readdir(dirp);
if (pdire -&gt; d_type == DT_REG)
    /*普通文件*/
</code></pre>
<h3 id="closedir">closedir</h3>
<p>关闭opendir所打开的目录</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int closedir(DIR *dirp);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>dirp：opendir函数的返回值</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：0</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<h2 id="-">文件描述操作函数</h2>
<h3 id="dup">dup</h3>
<p>复制一个文件描述符。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int dup(int oldfd);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>oldfd - 要复制的文件描述符</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：新的文件描述符，（取最小的且没被占用的文件描述符）</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h3 id="dup2">dup2</h3>
<p>在指定的文件描述符上， 复制文件描述符， 如指定的文件描述符被使用，先关闭。</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int dup2(int oldfd, int newfd);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>oldfd: 要复制的文件描述符</li>
<li>newfd： 指定的文件描述符</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：新的文件描述符</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<blockquote>
<p>XMind</p>
</blockquote>
<ul>
<li>补充：　重定向，　　</li>
</ul>
<h3 id="fcntl">fcntl</h3>
<p>变更打开的文件属性</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int fcntl(int fd, int cmd, ... /* arg */ );</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>这是一个可变参数的函数接口， 函数的行为取决于cmd参数</li>
<li>fd： 打开的文件描述符</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 与 cmd参数相关</li>
<li>失败： -1, 设置errno</li>
</ul>
</li>
<li><p><strong>典型的cmd参数</strong></p>
</li>
</ul>
<p>F_GETFL/F_SETFL : 用来获取/设置文件打开的flags</p>
<p>典型用法</p>
<pre><code class="lang-c">int flag = fcntl(fd, F_GETFL); /*获取*/

flag = flag | O_APPEND;
fcntl(fd, F_SETFL, flag)； /*典型用法*/
</code></pre>
<p>需要注意的是：</p>
<blockquote>
<p>  可以更改有限的几个，不是全部flags</p>
</blockquote>
<blockquote>
<p>常用的有： O_APPEND、O_NONBLOCK (常用)</p>
</blockquote>
<h2 id="-">练习</h2>
<ul>
<li><p>ls -l filename</p>
<ul>
<li>stat(lstat)</li>
</ul>
</li>
<li><p>遍历当前目录，只显示目录文件</p>
<ul>
<li>opendir/readdir/closdir</li>
</ul>
</li>
</ul>
<h1 id="-">进程控制</h1>
<p><strong> 学习目标 </strong></p>
<ul>
<li>了解进程相关的概念</li>
<li>掌握fork/getpid/getppid函数的使用</li>
<li>熟练掌握ps/kill命令的使用</li>
<li>熟练掌握execl/execlp函数的使用</li>
<li>说出什么是孤儿进程什么是僵尸进程</li>
<li>熟练掌握wait函数的使用</li>
<li>熟练掌握waitpid函数的使用</li>
</ul>
<h2 id="-">进程相关概念</h2>
<blockquote>
<p>简单介绍一下进程相关的概念，在后续编码当中， 了解即可。</p>
</blockquote>
<h3 id="-">程序和进程</h3>
<ul>
<li><p>程序: 二进制文件（代码.text和数据.data）,占用的磁盘空间</p>
</li>
<li><p>进程: 程序的一次运行，所谓&quot;./a.out + Enter&quot;, 就是讲程序a.out的代码和数据拷贝内存中，通过cpu解析代码</p>
<ul>
<li>所有的数据都在内存中</li>
<li>需要占用更多的系统资源</li>
<li>cpu,物理内存</li>
</ul>
<p>我们用剧本和演出的关系，来比喻程序和进程的关系。 </p>
</li>
</ul>
<h3 id="-">并行和并发</h3>
<p>并发：　微观上串行，　宏观上并行。　这句话的含义是：并发是个时间段的概念，不是一个时间点</p>
<p><img src="./images/并发-并行.png" alt="并行、并发"></p>
<p>并行：　程序在任一时间点也是并行的，如：　在多cpu计算机中， 一个cpu编码，一个cpu听音乐。</p>
<h3 id="pcb">pcb</h3>
<p>进程是一个动态的过程，有其创建、运行、消亡的过程。 用进程控制块来记录进程生存期间的一些信息：</p>
<p> 本质上就是内核中的一个结构体</p>
<ul>
<li>文件描述符表</li>
<li>pid： 进程的ID</li>
<li>pwd： 当前的工作路径</li>
<li>工作状态：一般来讲是三种，　就绪，运行，挂起（阻塞）。　再加上初始（创建）、终止，有书也说５种状态</li>
<li>代码的执行位置： 当状态切换的时候，保存当前当前代码的执行位置。</li>
<li>umask 掩码</li>
<li>用户ID, 组ID</li>
<li>进程可用的资源限制（ulimit -a）</li>
<li>进程的环境（PATH、 LD_LIBRARY_PATH）</li>
</ul>
<p>。。。。。。。。。。。。。</p>
<h3 id="-">进程的五种状态</h3>
<ul>
<li>创建</li>
<li>就绪： 满足运行所需要的全部资源，就差cpu</li>
<li>执行： 程序在运行。</li>
<li>阻塞（挂起）： 如read设备，数据没有准备好， 执行sleep</li>
<li>终止： 只能在执行态转入终止</li>
</ul>
<p><img src="./images/02-进程状态.jpg" alt="进程的五种状态"></p>
<h3 id="-">进程的地址空间</h3>
<p>　也称之为进程的虚拟地址空间，　
　
当程序（代码＋数据）加载内存中，大体布局如下图所示：　</p>
<p><strong>32位的进程地址空间</strong></p>
<p><img src="./images/link.addrspace.png" alt="32位地址空间"></p>
<p><strong>64位的地址空间</strong></p>
<p><img src="./images/64-进程地址空间.png" alt="64位地址空间"></p>
<blockquote>
<p>虚拟地址空间好比你的信用卡的信用额度，　比如你额度为１００ｗ（虚拟空间），　是否意味着，你身上随时带着１w张毛爷爷（物理内存）呢，</p>
</blockquote>
<p>　答：　不是的，　额度仅表示你可用的空间范围，具体到用时，　随时从取款机（系统）取款（申请）就可以了</p>
<h2 id="-">进程控制</h2>
<blockquote>
<p>探讨一下进程创建， 查看， 杀死</p>
</blockquote>
<h3 id="fork">fork</h3>
<p>用来创建子进程， 创建子进程的那个进程通常成为父进程</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>pid_t fork(void);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>无</li>
</ul>
</li>
<li><p><strong>函数返回值</strong></p>
<ul>
<li>失败： -1， 并设置errno</li>
<li>成功： 在父进程中，返回子进程的PID， 在子进程返回0，  </li>
</ul>
</li>
</ul>
<h3 id="-">进一步理解进程创建</h3>
<p>参考图</p>
<ul>
<li><p>fork函数的返回值</p>
<ul>
<li><blockquote>
<p>0, 父进程的返回值， 此时处于父进程</p>
</blockquote>
</li>
<li>=0,子进程的返回值, 此时处于子进程</li>
</ul>
</li>
<li><p>子进程创建成功之后,代码的执行位置</p>
<ul>
<li>父进程执行到了哪儿,子进程就从哪开始执行, 准确的说，是从fork的返回
<img src="./images/process.fork.png" alt="进程执行"></li>
</ul>
</li>
<li><p>父子进程的执行顺序?</p>
<ul>
<li>未定，取决于调度算法，调度到谁，谁抢到cpu谁执行 </li>
</ul>
</li>
<li><p>如何区分父子进程?</p>
<ul>
<li>通过fork函数的返回值</li>
</ul>
</li>
<li><p>调用一次，返回两次，</p>
<ul>
<li>简单说，就是fork创建一个pcb，排到就绪队列中去，分到cpu就会执行。</li>
</ul>
</li>
</ul>
<h3 id="getpid-getppid">getpid/getppid</h3>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>pid_t getpid(void); </li>
<li>pid_t getppid(void);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>无</li>
</ul>
</li>
<li><p><strong>函数返回值</strong>   </p>
<ul>
<li>失败： 不会失败</li>
<li>成功： getpid返回当前进程的id，getppid返回父进程的id</li>
</ul>
</li>
</ul>
<h3 id="-">练习</h3>
<ul>
<li><p>编写程序, 创建一个子进程。</p>
</li>
<li><p>编写程序,循环创建多个子进程。</p>
<ul>
<li>多个子进程是兄弟关系。(典型的多进程创建)   </li>
</ul>
</li>
<li><p>进程共享</p>
<ul>
<li>测试父子进程是否共享全局变量</li>
</ul>
</li>
</ul>
<h3 id="ps">ps</h3>
<p> 用来查看当前系统进程相关的信息</p>
<ul>
<li><strong>典型用法</strong></li>
</ul>
<p>显示全面的信息</p>
<pre><code class="lang-bash">ps aux | grep &quot;xxx&quot;
ps aux | less
</code></pre>
<p>以树型方式显示</p>
<pre><code class="lang-bash">$ ps axjf 
$ ps axjf | less
</code></pre>
<h3 id="kill">kill</h3>
<p> 向指定的进程发送信号</p>
<ul>
<li>发送SIGILL（9）信号，杀死编号为pid的进程</li>
</ul>
<pre><code class="lang-bash">kill -9 PID
</code></pre>
<h2 id="exec-">exec函数族</h2>
<blockquote>
<p>exec函数组的主要作用就是用指定的程序（.text+.data）替换当前进程空间中的.text和.data</p>
</blockquote>
<ul>
<li><p>exec函数族</p>
<ul>
<li>让父子进程执行不相干的操作</li>
<li>能够替换进程地址空间中的源代码.txt段</li>
<li>当前程序中调用另外一个应用程序<ul>
<li>首先想到exec之前需要fork</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：不返回</li>
<li>失败: 返回，<ul>
<li>此处一般的处理是： 打印错误信息,退出当前进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="execl">execl</h3>
<p>执行指定的程序，一般用来执行自己实现的程序</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int execl(const char <em>path, const char </em>arg, ... /<em> (char  </em>) NULL */);</li>
</ul>
</li>
<li><p><strong>函数接口</strong></p>
<ul>
<li>path: 要执行的程序的<strong>绝对路径</strong></li>
<li>arg: 要执行的程序的需要的参数, <ul>
<li>特别注意第一个arg从arg0开始，也可以解读为占位。</li>
<li>从第二个arg开始，为命令参数， 以NULL</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：不返回</li>
<li>失败: 返回，<ul>
<li>此处一般的处理是： 打印错误信息,退出当前进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例， 在当前进程中验证ececl基本用法</p>
</blockquote>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h3 id="execlp">execlp</h3>
<p>可执行PATH环境变量能够搜索到的程序， 多个p表示环境变量</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int execlp(const char <em>file, const char </em>arg, ... /<em> (char  </em>) NULL */);</li>
</ul>
</li>
<li><p><strong>函数接口</strong></p>
<ul>
<li>file: 执行的程序的名字（不带/）， 检索PATH路径, 如带/ 则忽略PATH</li>
<li>arg: 要执行的程序的需要的参数, <ul>
<li>特别注意第一个arg从arg0开始，也可以解读为占位。</li>
<li>从第二个arg开始，为命令参数， 以NULL</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：不返回</li>
<li>失败: 返回，<ul>
<li>此处一般的处理是： 打印错误信息,退出当前进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例， 在fork子进程进程中验证ececlp基本用法</p>
</blockquote>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h3 id="-">补充</h3>
<ul>
<li><p>int execle(const char <em>path, const char </em>arg, ... /<em>, (char </em>) NULL, char <em> const envp[] </em>/);</p>
<ul>
<li>参数：<ul>
<li>path = &quot;/bin/ps&quot;；</li>
<li>arg = 。。。。</li>
<li>char *const envp[] ={&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;, NULL}; </li>
</ul>
</li>
<li>execle(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL, envp); </li>
</ul>
</li>
<li><p>int execv(const char <em>path, char </em>const argv[]);</p>
<ul>
<li>参数:<ul>
<li>path = &quot;/bin/ps&quot;</li>
<li>char* argv[] = {&quot;ps&quot;, &quot;aux&quot;, NULL};</li>
</ul>
</li>
<li>execv(&quot;/bin/ps&quot;, argv);</li>
</ul>
</li>
<li><p>int execvp(const char <em>file, char </em>const argv[]);</p>
<ul>
<li>参数<ul>
<li>file = &quot;ps&quot;;</li>
<li>char *argv[]= {&quot;ps&quot;, &quot;aux&quot;, NULL};</li>
</ul>
</li>
<li>execvp(&quot;ps&quot;, argv);</li>
</ul>
</li>
<li><p>int execve(const char <em>path, char </em>const argv[], char *const envp[])</p>
<ul>
<li>参数：<ul>
<li>path = “/bin/ps” </li>
<li>char *argv[] = {&quot;ps&quot;, &quot;aux&quot;, NULL};</li>
<li>char *envp[] = {&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;, NULL}; </li>
</ul>
</li>
<li><p>execve(&quot;/bin/ps&quot;, argv, envp);</p>
<p> int execvpe(const char <em>file, char </em>const argv[],</p>
<pre><code>             char *const envp[]);
</code></pre></li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li><p>不带字母p（表示path）的exec函数第一个参数必须是程序的相对路径或绝对路径，例如&quot;/bin/ls&quot;或&quot;./a.out&quot;，而不能是&quot;ls&quot;或&quot;a.out&quot;。</p>
</li>
<li><p>对于带字母p的函数：</p>
<ul>
<li>如果参数中包含/，则将其视为路径名。 忽略PATH</li>
<li>否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。</li>
</ul>
</li>
<li><p>带有字母l（表示list）的exec函数要求将新程序的每个命令行参数都当作一个参数传给它，命令行参数的个数是可变的，因此函数原型中有...，...中的最后一个可变参数应该是NULL.</p>
</li>
<li><p>对于以e（表示environment）结尾的exec函数，可以把一份新的环境变量表传给它，其他exec函数仍使用当前的环境变量表执行新程序。</p>
</li>
</ul>
</li>
<li><p>代码示例</p>
</li>
</ul>
<pre><code class="lang-c">char *const ps_argv[] ={&quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL};
char *const ps_envp[] ={&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;, NULL};

execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL);
execv(&quot;/bin/ps&quot;, ps_argv);
execle(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL, ps_envp);
execve(&quot;/bin/ps&quot;, ps_argv, ps_envp);
execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL);
execvp(&quot;ps&quot;, ps_argv);
</code></pre>
<p>exec之间的关系 如图所示</p>
<p><img src="./images/process.exec.png" alt="exec一族"></p>
<h2 id="-">进程回收</h2>
<blockquote>
<p>进程占用系统资源（cpu、内存、打开的文件啦）， 因此进程终止后，需要回收进程，以释放资源。 </p>
</blockquote>
<blockquote>
<p>在探讨进程的资源的回收前， 我们给出两个定义</p>
</blockquote>
<h3 id="-">孤儿进程</h3>
<p> 简单说，就是父进程死了，子进程还活着， 此时子进程称为孤儿进程。</p>
<ul>
<li><p>子进程死亡后，需要由父进程回收子进程占用的系统资源</p>
<ul>
<li>子进程结束之后,能够释放用户区空间</li>
<li>释放不了pcb,必须由父进程释放</li>
</ul>
</li>
<li><p>注：孤儿被init进程领养,init进程变为孤儿进程的父亲</p>
<ul>
<li>所谓领养， 就是认干爹（对于init来说是认干儿子）</li>
<li>由init进程负责回收子进程的资源。</li>
</ul>
</li>
</ul>
<h3 id="-">僵尸进程</h3>
<p>简单的说， 就是子进程死了， 父进程还活着，且还没有释放子进程pcb，此时称之为僵尸进程。</p>
<p><strong>结论: 孤儿进程不会浪费系统资源，僵尸进程占用系统资源,且kill不掉</strong></p>
<h3 id="-">进程回收</h3>
<h4 id="wait">wait</h4>
<p>回收子进程资源 （直译，获取进程的状态） </p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>pid_t wait(int *wstatus);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>wstatus： 标志子进程是如何死的<ul>
<li>WIFEXITED(wstatus):为非0， 正常退出</li>
<li>WIFSIGNALED(status):为非0 被某个信号杀死了</li>
<li>WTERMSIG(status)： 如宏WIFSIGNALED为真， 使用此宏取得使进程终止的那个信号的编号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：&gt;0: 回收是子进程对应的pid</li>
<li>失败: -1: 回收失败</li>
</ul>
</li>
<li><p><strong>调用一次只能回收一个子进程</strong></p>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<blockquote>
<p>XMind总结</p>
</blockquote>
<h4 id="waitpid">waitpid</h4>
<p>回收子进程的资源（获取状态）</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>pid_t waitpid(pid_t pid, int *wstatus, int options);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>pid:<ul>
<li>pid == -1 等待任一子进程。与wait等效</li>
<li>pid &gt; 0 等待其进程ID与pid相等的子进程</li>
<li>id == 0 等待其组ID等于调用进程的组I D的任一子进程 （和自己组相同的子进程）</li>
<li>pid &lt; -1： 等待其组ID等于pid的绝对值的任一子进程 （制定组id的子进程）</li>
</ul>
</li>
<li>wstatus: 同wait</li>
<li>options: <ul>
<li>0: 阻塞等待，同wait</li>
<li>WNOHANG ： 无子进程，立即返回</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功：&gt;0: 回收是子进程对应的pid</li>
<li>失败: -1: 回收失败</li>
</ul>
</li>
<li><p>调用一次只能回收一个子进程</p>
</li>
</ul>
<h2 id="-">练习</h2>
<ul>
<li><p>编写测试程序, 测试父子进程之间是否共享文件.</p>
<ul>
<li>共享文件 - 文件描述符</li>
<li>文件描述符 -》 pcb</li>
<li>打开一个文件 - fd</li>
<li>fork();</li>
<li>父进程 - write</li>
<li>子进程 - read () </li>
<li>1.子进程需要延时， 确保父进程先执行， 2， 子进程要lseek到文件头，再读。</li>
</ul>
</li>
<li><p>父进程fork三个子进程:</p>
<ul>
<li>其中一个调用ps命令;</li>
<li>一个调用自定义应用程序;</li>
<li>一个调用会出现段错误的程序。</li>
</ul>
</li>
</ul>
<p>父进程回收三个子进程(waitpid),并且打印三个子进程的退出状态。</p>
<ul>
<li><strong>段错误</strong><ul>
<li>访问了非法内存</li>
<li>访问了不可写的区域进行写操作</li>
<li>栈空间溢出</li>
</ul>
</li>
</ul>
<pre><code class="lang-c">char* p = “hello,world”
p【0】=‘a’;
</code></pre>
<h1 id="-">进程间通信</h1>
<p><strong> 学习目标 </strong></p>
<ul>
<li>熟练使用pipe进行父子进程间通信</li>
<li>熟练使用pipe进行兄弟进程间通信</li>
<li>熟练使用fifo进行无血缘关系的进程间通信</li>
<li>熟练掌握mmap函数的使用</li>
<li>掌握mmap创建匿名映射区的方法</li>
<li>使用mmap进行有血缘关系的进程间通信</li>
<li>使用mmap进行无血缘关系的进程间通信</li>
</ul>
<h2 id="-">进程间通信相关概念</h2>
<blockquote>
<p>为什么要通信</p>
</blockquote>
<blockquote>
<p>解决通信的两个关键点： 空间，时序</p>
</blockquote>
<ul>
<li>什么是IPC<ul>
<li>进程间通信</li>
<li>InterProcess Communication
*进程间通信常用的4种方式</li>
<li>管道 - 简单</li>
<li>信号 - 系统开销小</li>
<li>共享映射区 - (有无血缘关系的进程间通信都可以)<ul>
<li>本地套接字 - 稳定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-">管道(匿名)</h2>
<h3 id="-">管道的概念</h3>
<p> 类似 自来水管子， 流出的一端称之为读端r; 流入的一端称之为写端</p>
<ul>
<li><p>本质: 一段内核缓冲区</p>
<ul>
<li>伪文件 - 不占用磁盘空间</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>两部分:<ul>
<li>读端,写端,对应两个文件描述符</li>
<li>数据写端流入, 读端流出</li>
</ul>
</li>
<li>操作管道的进程被销毁之后,管道自动被释放了</li>
<li>管道默认是阻塞的。<ul>
<li>读写都会阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-">管道的实现</h3>
<p> 管道的实现就是一个队列， 先进先出</p>
<ul>
<li>内核实现方式:队列<ul>
<li>环形队列</li>
<li>特点:先进先出</li>
</ul>
</li>
<li>缓冲区大小:<ul>
<li>默认4k</li>
<li>大小会根据实际情况做适当调整</li>
</ul>
</li>
</ul>
<h3 id="-">管道的局限性</h3>
<ul>
<li><p>队列:</p>
<ul>
<li>数据只能读取一次,不能重复读取</li>
</ul>
</li>
<li><p>半双工:</p>
<ul>
<li>单工:遥控器</li>
<li>半双工:对讲机<ul>
<li>数据传输的方向是单向的</li>
</ul>
</li>
<li>双工:电话</li>
</ul>
</li>
<li>匿名管道:<ul>
<li>适用于有血缘关系的进程</li>
</ul>
</li>
</ul>
<h3 id="pipe">pipe</h3>
<p>创建匿名管道</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int pipe(int fd[2]);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>fd- 传出参数<ul>
<li>fd[0] - 读端</li>
<li>fd[1] - 写端</li>
</ul>
</li>
<li>记忆： 文件描述符0， 标准输入，可理解为读</li>
<li>记忆： 文件描述符1， 标准输出， 可理解为写</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
</li>
</ul>
<blockquote>
<p>代码示例，单个进程完成读写</p>
</blockquote>
<blockquote>
</blockquote>
<h3 id="-">父子进程使用管道通信</h3>
<ul>
<li>父子进程间通信是否需要sleep函数?<ul>
<li>父 写 -- 写的慢</li>
<li>子 读 -- 读的快</li>
</ul>
</li>
</ul>
<p>注意事项:</p>
<ul>
<li><p>由父进程 --&gt; 子进程， 父写，子读</p>
<ul>
<li>父进程关闭读端</li>
<li>子进程关闭写段</li>
</ul>
</li>
<li><p>由子进程 --&gt; 父进程， 子写，父读</p>
<ul>
<li>子进程关闭读端</li>
<li>父进程关闭写段</li>
</ul>
</li>
</ul>
<p>简单来说，就是一个进程保留一个，另一个关闭</p>
<h3 id="-">练习</h3>
<ul>
<li>父子进程间通信, 实现ps aux | grep bash<ul>
<li>数据重定向: dup2</li>
<li>execlp</li>
</ul>
</li>
</ul>
<p>▪ 兄弟进程间通信, 实现ps aux | grep bash</p>
<pre><code>* 父亲 - 资源回收
</code></pre><h3 id="-">管道的读写行为</h3>
<ul>
<li>读操作<ul>
<li>有数据<ul>
<li>read(fd) - 正常读,返回读出的字节数</li>
</ul>
</li>
<li>无数据<ul>
<li>写端全部关闭<ul>
<li>read解除阻塞,返回0</li>
<li>相当于读文件读到了尾部</li>
</ul>
</li>
<li>没有全部关闭<ul>
<li>read阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写操作</p>
<ul>
<li>读端全部关闭<ul>
<li>管道破裂,进程被终止</li>
<li>内核给当前进程发信号SIGPIPE
▪ 读端没全部关闭</li>
<li>缓冲区写满了<ul>
<li>write 阻塞</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区没有满<ul>
<li>write写入数据，返回</li>
</ul>
</li>
</ul>
</li>
<li><p>如何设置非阻塞?</p>
<ul>
<li><p>默认读写两端都阻塞</p>
</li>
<li><p>设置读端为非阻塞pipe(fd)</p>
<ul>
<li>fcntl - 变参函数<ul>
<li>复制文件描述符</li>
<li>设置open打开的flags</li>
</ul>
</li>
</ul>
</li>
<li>设置方法:<ul>
<li>获取原来的flags<ul>
<li>int flags = fcntl(fd[0], F_GETFL);</li>
</ul>
</li>
<li>设置新的flags</li>
<li>flag |= O_NONBLOCK;</li>
<li>fcntl(fd[0], F_SETFL, flags);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-">查看管道缓冲区大小（扩展）</h3>
<ul>
<li><p>命令</p>
<ul>
<li>ulimit -a</li>
</ul>
</li>
<li><p>函数(知道有这么个函数)</p>
<ul>
<li>fpathconf</li>
</ul>
</li>
</ul>
<h2 id="fifo">fifo</h2>
<h3 id="-">特点</h3>
<ul>
<li>有名管道</li>
<li>在磁盘上有这样一个文件 ls -l -&gt; p</li>
<li>伪文件,在磁盘大小永远为0</li>
<li>在内核中有一个对应的缓冲区</li>
<li>半双工的通信方式</li>
</ul>
<h3 id="-">使用场景</h3>
<ul>
<li>没有血缘关系的进程间通信</li>
</ul>
<h3 id="-">创建方式</h3>
<ul>
<li>命令:mkfifo 管道名</li>
<li>函数:mkfifo</li>
</ul>
<h3 id="fifo-io-">fifo文件可以使用IO函数进行操作</h3>
<ul>
<li>open/close</li>
<li>read/write</li>
<li>不能执行lseek操作</li>
</ul>
<h3 id="-">进程间通信</h3>
<ul>
<li><p>fifo文件 --- myfifo</p>
<ul>
<li>两个不相干的进程 A(a.c) B(b.c)</li>
<li><p>a.c ---&gt; read</p>
<ul>
<li>int fd = open(&quot;myfifo&quot;, O_RDONLY);</li>
<li>read(fd, buf, sizeof(buf));</li>
<li>close(fd);</li>
</ul>
</li>
<li><p>b.c ----- write</p>
<ul>
<li>int fd1 = open(&quot;myfifo&quot;, O_WRONLY);</li>
<li>write(fd1, &quot;hello, world&quot;, 11);</li>
<li>close(fd1);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-mmap">内存映射mmap</h2>
<blockquote>
<p>这是最快的进程间通信方式，</p>
</blockquote>
<h3 id="mmap">mmap</h3>
<p> 将磁盘文件的数据映射到内存, 用户通过修改内存就能修改磁盘文件</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>void <em>mmap(void </em>addr, size_t length, int prot, int flags, int fd, off_t offset);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>addr:  映射区首地址, 传NULL, 由系统决定</li>
<li>length：映射区的大小，　通常为文件的大小<ul>
<li>不能为0</li>
</ul>
</li>
<li>prot:  映射区权限<ul>
<li>PROT_READ -- 映射区要有读权限</li>
<li>PROT_WRITE :</li>
<li>PROT_READ | PROT_WRITE</li>
<li>PROT_EXEC:</li>
<li><strong>注</strong>：此处给定的权限，需要在open时flags范围内。</li>
</ul>
</li>
<li>flags：标志位参数
  *　MAP_SHARED：修改了内存数据会同步到磁盘<ul>
<li>MAP_PRIVATE:修改了内存数据不会同步到磁盘　 </li>
</ul>
</li>
<li>fd：文件描述符<ul>
<li>要映射的文件对应fd , open()得到</li>
</ul>
</li>
<li>offset：映射文件的偏移量<ul>
<li>映射的时候文件指针的偏移量</li>
<li>必须是4k的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 执行映射区的指针</li>
<li>失败： MAP_FAILED， 并设置errno</li>
</ul>
</li>
</ul>
<p><img src="./images/io.mmap.png" alt="ｍｍａｐ映射"></p>
<h3 id="munmap">munmap</h3>
<blockquote>
<p>类似于ｏｐｅｎ/close, malloc/free</p>
</blockquote>
<p>解除映射关系</p>
<ul>
<li><p><strong>函数原型</strong></p>
<ul>
<li>int munmap(void *addr, size_t length);</li>
</ul>
</li>
<li><p><strong>函数参数</strong></p>
<ul>
<li>addr: mmap的返回值</li>
<li>length： mmap空间的大小, 第二个参数</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li>成功： 0</li>
<li>失败： -1， 并设置errno</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例。映射一个文件，测试同步ＭＡＰ_SHARED</p>
</blockquote>
<blockquote>
<p>XMind小结</p>
</blockquote>
<h3 id="-">思考问题</h3>
<ul>
<li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</li>
<li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</p>
</li>
<li><p>如果文件偏移量为1000会怎样?</p>
</li>
<li>如果不检测mmap的返回值会怎样?</li>
<li>mmap什么情况下会调用失败?</li>
<li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li>
<li>mmap后关闭文件描述符,对mmap映射有没有影响?</li>
<li>对ptr越界操作会怎样?</li>
</ul>
<h3 id="-">进程间通信</h3>
<ul>
<li><p>有血缘关系的</p>
<ul>
<li>父子进程共享内存映射区</li>
</ul>
</li>
<li><p>没有血缘关系的进程间通信</p>
<ul>
<li>如何通信?</li>
</ul>
</li>
<li><p>mmap 实现内存映射:</p>
<ul>
<li>必须有一个文件</li>
<li>文件数据什么时候有用:<ul>
<li>单纯文件映射</li>
<li>进程间通信:
  文件数据是没有用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-">练习　</h2>
<ul>
<li>利用ｍｍａｐ实现父子进程间通信</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>